//https://blog.csdn.net/tennysonsky/article/details/79103434  源代码可以在这个博客中找到
// 跟着视频学的，视频的网址是https://www.bilibili.com/video/av20432910/?p=55，分上中下三个
package main //每个go文件必须具有package关键字，且在第一行，表示go文件属于哪个包

import (
	"fmt"
)

//关键字，标示符，注释，基础结构

//go 的注释与C，C++一样
/*
多行注释
*/

//类型都是在名字之后定义，在这块即使不定义也可以，go会自动推断
const NAME int = 56       //常量的名字最好是大写
var name string = "imooc" //在main函数之外定义的变量就是全局变量，可以在包里面被调用

//一般类型声明,相当于类型别名
type ChenInt int

//结构的声明
type learn struct {
}

//接口的声明
type Ilearn interface {
	//接口的名字一般以I开头
}

//函数定义
func machine_learning() {

}

//记不住包名没有问题，只要记住函数名即可，goland会自动补全，引入多个包时，goland会
//自动添加括号
//main函数
func main() {
	fmt.Println(NAME)
	fmt.Println(name)
}

//,   go 语言以包作为管理单位
//2.每个函数必须先声明包
//3.程序必须有一个main包
//go 函数有且只有一个入口函数，main
//入口函数，go语言函数左括号必须要放在函数名同行，不允许换行
//调用函数，大部分都需 要导入包
//package，import别名，路径，".",   "_"的使用说明

/*
1.package是最基本的分发单位和工程管理中依赖关系的体现
2.每个go语言源代码文件开头都拥有一个package声明，表示源码文件所属代码包
3.要生成go语言可执行程序，必须要有main的package包，且必须在该包下有main（）函数
4.同一个路径下只能存在一个package，一个package可以拆成多个源文件组成；所以在同一个
	工程中一般都会出现很多文件夹
*/
//package 包名 尽量与所属文件夹名称一致

/*
go基础语法----import
1，import语句可以导入源代码文件所依赖的package包
2，不得导入源代码文件中没有用到的package，否则go语言编译器会报编译错误
3，import语法格式主要有以下两种:
	(1)第一种	import "package1"
			import "package2"
			import "package3"
	（2）第二种  import（    注意是小括号，而不是大括号
						"package1"
						"package2"
						"package3")
import 原理：
	1.如果一个main导入其他包，包将被顺序导入
	2.如果导入的包中依赖其他包（包B），会首先带入B包，然后初始化B包中的常量和变量，
		最后如果B包中有init，会自动执行init（）
	3.所有包导入完成后才会对main中常量和变量进行初始化，然后执行main中的init函数（如果存在）
		，最后执行main函数
	4.如果一个包被导入多次，则该包只会被导入一次

综上：所以代码执行的顺序与导入包的顺序有直接关系，不同的导入顺序可能会有完全不同的输出
*/

/*
go语言 基础语法---import别名，路径，".",   "_"
1.别名操作的含义是：将导入的包命名为另一个容易记忆的别名
2.点（.)操作的含义是：点（.）标识的包导入后，调用该包中函数时可以省略前缀包名（不推荐）
3.下划线（_)操作的含义是：导入该包，但不导入整个包，而是执行该包中的init函数，
	因此无法通过包名来调用包中的其他函数。使用下划线（_）操作往往是为了注册包中的引擎，
	让外部可以方便的使用

例子：import（  formant "fmt") 别名
	import ( . "fmt"),在程序中导入函数，不需要再加包名，但是不推荐这种写法
	import
*/

//go变量，函数可见规则
//包括变量声明，初始化与赋值，变量可见性规则，常量，常量声明和iota的使用
/*
单个变量的声明和赋值
1）变量的声明格式：var  <变量名称>  [变量类型]
2）变量的赋值格式： <变量名称>  =  <值，表达式，函数等>
3）声明和赋值同时进行：var  <变量名称>  [变量类型]=  <值，表达式，函数等>
4）分组声明格式
	var（
			i int
			j float32
			name string
		)

5)同一行声明多个变量和赋值： var a,b,c int =1,2,3或者a,b:=1,2(这种方式只能用在函数体内）
6)全局变量的声明必须使用var关键词，局部变量则可以省略
7）特殊变量下划线 "_"：相当于垃圾桶，丢给垃圾桶，则在之后的程序运行中不再要这个值
8）go中不存在隐式转换，类型转换必须是显式的
9）类型转换只能发生在两种兼容类型之间
10）类型转换格式：<变量名称>  [:](可有可无，若变量未指定类型，则需要加)= <目标类型>（<需要转换的变量>）

var flag bool
flag=1   （编译不通过）
或者flag=bool（1） 一样不通过，，go语言中bool变量，不能用整型替换，并不是其他语言的非负为真

*/
//int的默认值是0 ，string的默认值是空字符串
/*
变量可见性原则：
1.大写字母开头的变量是可导出的，也就是其他包可以读取的，是公用变量（也就是在其他包可以使用）
2、小写字母开头的就是不可导出的，是私有变量

常量用const关键字定义
*/

/*
go语言---特殊常量iota的使用
1.iota在const关键字出现时将被重置为0，并且iota只能在常量定义中使用
2、const中每新增一行常量声明将使iota计数一次（在组合定义中）
3，iota常见使用法：跳值使用法，插队使用法，表达式隐式使用法，单行使用法
4.iota在多行常量定义中会被重置为0，是在组合定义中才会发挥作用
*/
//
//const (
//	a=iota   //a为0
//	b=iota	//b为1
//	c=iota	//c为2
//)

//调值使用法,通过下划线使用

/*
go 语言中条件判断语句和其他语言基本类似，
但是多了一个select语句：select语句类似于switch语句，但是select会随机执行一个
可运行的case，如果没有case可运行，他将阻塞，直到有case可运行

*/
/*
if语句注意事项：
1，if语句不可以脱离函数，独立存在，语法为花括号
2，不需要使用括号将条件包含起来
3，大括号{}必须存在，即使是只有一条语句
4，在if之后，条件语句之前，可以添加变量初始化语句，使用分号进行分隔
5.左括号必须在if或者else的同一行
6.if和别的语言不同的地方在于，if可以进行初始化
if a:=3;a==3{}  初始化语句以分号隔开
*/

func test() {
	num := 1
	if true {

	}

	if true {

	} else if true {

	} else {
	}
	//go中的switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch
	//但是可以用fallthrough强制执行后面的case代码，相当于不加break，后面的条件将无条件执行

	switch num { //switch后面写的是变量本身，并不是条件判断语句
	case 1:
		fmt.Println("按下的是%d楼\n", num)

		//C语言中switch语句后需要加break
		//go语言保留break关键字，用来跳出switch语句，但是go中其实不用写break，因为默认已经包含
	case 2: //go 语言中case语句可以带条件，比如case num>5:
		fmt.Println("按下的是%d楼\n", num)

	case 3:
		fmt.Println("按下的是%d楼\n", num)
	default:
		fmt.Println("error")
	}
	//fmt.Scan()go语言中读取输入,取地址符

}

/* 慕课网：
我们表示这样一个数组类型的值的时候，应该把该类型的类型字面量写在最左边，然后用花括号包裹该值包含的若干元素。各元素之间以（英文半角）逗号分隔，即：

[3]int{1, 2, 3}
现在，我们把这个数组字面量赋给一个名为numbers的变量：

var numbers = [3]int{1, 2, 3}
注：这是一条变量声明语句。它在声明变量的同时为该变量赋值。

另一种便捷方法是，在其中的类型字面量中省略代表其长度的数字，像这样：

var numbers = [...]int{1, 2, 3}
这样就可以免去我们为填入那个数字而数出元素个数的工作了。

接下来，我们可以很方便地使用索引表达式来访问该变量的值中的任何一个元素，例如：

numbers[0] // 会得到第一个元素
numbers[1] // 会得到第二个元素
numbers[2] // 会得到第三个元素
注：索引表达式由字符串、数组、切片或字典类型的值（或者代表此类值的变量或常量）和由方括号包裹的索引值组成。在这里，索引值的有效范围是[0, 3)。也就是说，
对于数组来说，索引值既不能小于0也不能大于或等于数组值的长度。另外要注意，索引值的最小有效值总是0，而不是1。

相对的，如果我们想修改数组值中的某一个元素值，那么可以使用赋值语句直接达到目的。例如，我们要修改numbers中的第二个元素的话，如此即可：

numbers[1] = 4
虽然数组的长度已经体现在了它的类型字面量，但是我们在很多时候仍然需要明确的获得它，像这样：

var length = len(numbers)
注：len是Go语言的内建函数的名称。该函数用于获取字符串、数组、切片、字典或通道类型的值的长度。我们可以在Go语言源码文件中直接使用它。

最后，要注意，如果我们只声明一个数组类型的变量而不为它赋值，那么该变量的值将会是指定长度的、其中各元素均为元素类型的零值（或称默认值）的数组值。例如，
若有这样一个变量：

var numbers2 [5]int
则它的值会是

[5]int{0, 0, 0, 0, 0}
*/

/*
循环结构：
go中没有while和do-while，只有for，和迭代器range

for的语法：
	for 初始化条件; 判断条件; 条件变化{        注意是分号
		}

关键字range会返回两个值，第一个返回值是元素的数组下标，第二个返回值是元素的值



*/
//Println :可以打印出字符串，和变量
//Printf : 只可以打印出格式化的字符串,可以输出字符串类型的变量，不可以输出整形变量和整形
//进行结构化输出的时候不能使用println,当需要格式化输出信息时一般选择 Printf，其他时候用 Println 就可以

/*  来自知乎的回答：
range就是Go开发者给语言自带的数据结构（slice、map、chan）开的后门。
不要拿C语言的for来理解Go的for，这里的“结束循环”的条件是循环至a的最后一个元素
range不是函数（你觉得这像函数吗？），这是statement
*/
func loop() {
	//计算1+2+3...10
	sum := 10
	for i := 1; i <= 10; i++ {
		sum += i
	}

	s := "abc"

	//若是通过for循环打印
	for i := 0; i < len(s); i++ {
		fmt.Printf("str[%d]=%c", i, s[i])
	}

	//迭代打印每个元素，默认返回两个值，一个是元素的位置，一个是元素本身,原理是一样的，不过这种写法更加简便
	for i, data := range s {
		fmt.Printf("str[%d]=%c", i, data)
	}

	for i, _ := range s { //第二个返回值。默认丢弃，返回元素的位置（下标）
		fmt.Printf("str[%d]=%c", i)

	}
	for i := range s {
		fmt.Println(s[i])
	}

	//range不是函数，而是statement，配合for循环，一起使用

}

//go 的函数
/*
定义函数的格式：
	func funcname(参数列表）（返回值列表）{
		return v1,v2  //可以返回多个值
函数定义完成后一定要在主程序中进行调用
1.无参无返回值
func test（）{
2，有参无返回值
	2.1普通参数列表（固定参数）
		func test(v1 int ,v2 int){  最好不要写成 v1,v2 int，虽然简洁，但是不易于看，给每个参数都声明类型

			调用函数传递的参数叫实参，定义函数时为形参
			fmt.Println(v1,v2)  可以在main函数中调用的时候赋值
		}
	2.2不定参数列表
		...type 为不定参数类型，可以接收0或多个实参
		func test（args ...int){

		}

}
*/
//不定参数类型
/*
注意：
不定参数只能放在形参中的最后一个参数，也可以有固定参数，最后按顺序赋值
*/
func test01(args ...int) {
	fmt.Println("len(args)", len(args)) //获取用户传递参数的个数
	sum := 0
	for i := 0; i < len(args); i++ {

		sum += args[i]
	}

	fmt.Println(sum) //自动对输入的参数进行求和

}

//

//不定参数传递，两个具有不定参数的函数互相调用
/*
全部参数都传递
func func1(tmp ...int){}
func func2(args ...int){
	func1(args...)
	}
部分参数传递
func func2（args[2:]...)  从args[2]开始开始（包括本身），把后面所有元素传递过去，通过切片进行实现
func func2（args[2:]...)  args[0]~args[2](不包括args[2]），全部传递过去
*/
